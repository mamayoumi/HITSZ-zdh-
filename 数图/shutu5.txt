#include <stdlib.h>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>

using namespace cv;
using namespace std;


void guass(Mat input, Mat* output, double sigma)
{
	
		double kernel[9] = { 0 };
		kernel[0] = 1 / (2 * 3.14 * sigma * sigma) * exp(-1 / sigma * sigma);
		kernel[1] = 1 / (2 * 3.14 * sigma * sigma) * exp(-0.5 / sigma * sigma);
		kernel[2] = kernel[0];
		kernel[3] = kernel[1];
		kernel[4] = 1 / (2 * 3.14 * sigma * sigma);
		kernel[5] = kernel[1];
		kernel[6] = kernel[0];
		kernel[7] = kernel[1];
		kernel[8] = kernel[0];
		double sum = kernel[4] + 4 * kernel[0] + 4 * kernel[1];

		for (int i = 1; i < input.rows - 1; i++)
		{
			for (int j = 1; j < input.cols - 1; j++)
			{
				(*output).at<Vec3b>(i, j)[0] =
					(uchar)((1.0 / sum) * (
						kernel[0] * input.at<Vec3b>(i - 1, j - 1)[0] +
						kernel[1] * input.at<Vec3b>(i - 1, j)[0] +
						kernel[2] * input.at<Vec3b>(i - 1, j + 1)[0] +
						kernel[3] * input.at<Vec3b>(i, j - 1)[0] +
						kernel[4] * input.at<Vec3b>(i, j)[0] +
						kernel[5] * input.at<Vec3b>(i, j + 1)[0] +
						kernel[6] * input.at<Vec3b>(i + 1, j - 1)[0] +
						kernel[7] * input.at<Vec3b>(i + 1, j)[0] +
						kernel[8] * input.at<Vec3b>(i + 1, j + 1)[0]
						));


				(*output).at<Vec3b>(i, j)[1] =
					(uchar)((1.0 / sum) * (
						kernel[0] * input.at<Vec3b>(i - 1, j - 1)[1] +
						kernel[1] * input.at<Vec3b>(i - 1, j)[1] +
						kernel[2] * input.at<Vec3b>(i - 1, j + 1)[1] +
						kernel[3] * input.at<Vec3b>(i, j - 1)[1] +
						kernel[4] * input.at<Vec3b>(i, j)[1] +
						kernel[5] * input.at<Vec3b>(i, j + 1)[1] +
						kernel[6] * input.at<Vec3b>(i + 1, j - 1)[1] +
						kernel[7] * input.at<Vec3b>(i + 1, j)[1] +
						kernel[8] * input.at<Vec3b>(i + 1, j + 1)[1]
						));

				(*output).at<Vec3b>(i, j)[2] =
					(uchar)((1.0 / sum) * (
						kernel[0] * input.at<Vec3b>(i - 1, j - 1)[2] +
						kernel[1] * input.at<Vec3b>(i - 1, j)[2] +
						kernel[2] * input.at<Vec3b>(i - 1, j + 1)[2] +
						kernel[3] * input.at<Vec3b>(i, j - 1)[2] +
						kernel[4] * input.at<Vec3b>(i, j)[2] +
						kernel[5] * input.at<Vec3b>(i, j + 1)[2] +
						kernel[6] * input.at<Vec3b>(i + 1, j - 1)[2] +
						kernel[7] * input.at<Vec3b>(i + 1, j)[2] +
						kernel[8] * input.at<Vec3b>(i + 1, j + 1)[2]
						));
			}
		}
	
}


void rgb2hsi(Mat* input, Mat* output)
{
	for (int i = 0; i < (*input).rows; i++)
	{
		for (int j = 0; j < (*input).cols; j++)
		{
			double b= (*input).at<Vec3b>(i, j)[0] / 255.f,
					g = (*input).at<Vec3b>(i, j)[1]/255.f ,
					r= (*input).at<Vec3b>(i, j)[2]/255.f;
			
			double num = 0.5 * (2 * r - g - b);
			double den = sqrt((r - g) * (r - g) + (r - b) * (g - b));
			if (den == 0)
			{
				(*output).at<Vec3b>(i, j)[0] = 0; // 分母为0自动取0
			}
			else
			{
				(*output).at<Vec3b>(i, j)[0] = b <= g ? (uchar)255 * acos(num / den) / (2 * 3.14) : (uchar)255 * (1 - acos(num / den) / (2 * 3.14));
			}

			float sum = b+g+r;
			if (sum == 0)
			{
				(*output).at<Vec3b>(i, j)[1] = 0;// 分母为0自动取0
			}
			else
			{
				(*output).at<Vec3b>(i, j)[1] = (uchar)255 * (1 - 3 * min(min(b, g), r) / sum);
			}

			(*output).at<Vec3b>(i, j)[2] = (uchar)255*sum/3;
			
		}
	}
}


void rgb2hsi2(Mat* input, Mat* output)
{
	for (int i = 0; i < (*input).rows; i++)
	{
		for (int j = 0; j < (*input).cols; j++)
		{
			double b = (*input).at<Vec3b>(i, j)[0] / 255.f,
				g = (*input).at<Vec3b>(i, j)[1] / 255.f,
				r = (*input).at<Vec3b>(i, j)[2] / 255.f;

			double num = 0.5 * (2 * r - g - b);
			double den = sqrt((r - g) * (r - g) + (r - b) * (g - b));
			if (den == 0)
			{
				(*output).at<Vec3b>(i, j)[0] = 0; // 分母为0自动取0
			}
			else
			{
				(*output).at<Vec3b>(i, j)[0] = (uchar)255 * acos(num / den) / ( 3.14);
			}

			float sum = b + g + r;
			if (sum == 0)
			{
				(*output).at<Vec3b>(i, j)[1] = 0;// 分母为0自动取0
			}
			else
			{
				(*output).at<Vec3b>(i, j)[1] = (uchar)255 * (1 - 3 * min(min(b, g), r) / sum);
			}

			(*output).at<Vec3b>(i, j)[2] = (uchar)255 * sum / 3;

		}
	}
}

Mat RGB2HSI(const Mat& rgb) {
	Mat hsi(rgb.rows, rgb.cols, rgb.type());
	float  H = 0, S = 0, I = 0;
	for (int i = 0; i < rgb.rows; i++)
		for (int j = 0; j < rgb.cols; j++) {
			float B = rgb.at<Vec3b>(i, j)[0] / 255.f,
				G = rgb.at<Vec3b>(i, j)[1] / 255.f,
				R = rgb.at<Vec3b>(i, j)[2] / 255.f;

			float num = (R - G + R - B) / 2,
				den = sqrt((R - G) * (R - G) + (R - B) * (G - B)),
				theta = acos(num / den);
			if (den == 0) H = 0; // 分母不能为0
			else H = B <= G ? theta / (2 * 3.14) : 1 - theta / (2 * 3.14);

			float sum = B + G + R;
			if (sum == 0) S = 0;
			else S = 1 - 3 * min(min(B, G), R) / sum;

			I = sum / 3.0;

			hsi.at<Vec3b>(i, j)[0] = H * 255;
			hsi.at<Vec3b>(i, j)[1] = S * 255;
			hsi.at<Vec3b>(i, j)[2] = I * 255;
		}
	return hsi;
}



void h_threshold_callback(int pos, void* usrdata)
{
	//cout << "h_min: " << pos << endl;
	
}

void s_threshold_callback(int pos, void* usrdata)
{
	//cout << "s_min: " << pos << endl;

}

void i_threshold_callback(int pos, void* usrdata)
{
	//cout << "i_min: " << pos << endl;

}

void H_threshold_callback(int pos, void* usrdata)
{
	//cout << "h_max: " << pos << endl;

}

void S_threshold_callback(int pos, void* usrdata)
{
	//cout << "s_max: " << pos << endl;

}

void I_threshold_callback(int pos, void* usrdata)
{
	//cout << "i_max: " << pos << endl;

}


void threshold(int h_min,int h_max, int s_min,int s_max, int i_min,int i_max, Mat* input, Mat* output)
{
	for (int i = 0; i < (*input).rows; i++)
	{
		for (int j = 0; j < (*input).cols; j++)
		{
			if (
				(*input).at<Vec3b>(i, j)[0] < h_max&& (*input).at<Vec3b>(i, j)[0] > h_min
				&& (*input).at<Vec3b>(i, j)[1] < s_max && (*input).at<Vec3b>(i, j)[1] > s_min
				&& (*input).at<Vec3b>(i, j)[2] < i_max && (*input).at<Vec3b>(i, j)[2] > i_min
				
				)
			{
				(*output).at<uchar>(i,j) = 255;
			}
			else
			{
				(*output).at<uchar>(i, j) = 0;
			}
			

		}
	}
}

int main()
{
	
	int h_min = 0;
	int s_min = 0;
	int i_min = 0;
	int h_max = 0;
	int s_max = 0;
	int i_max = 0;
	namedWindow("thresholdbar");
	Mat bar = Mat::zeros(img.rows, img.cols, CV_8UC1);
	imshow("thresholdbar", bar);
	createTrackbar("h_min", "thresholdbar", &h_min, 255, h_threshold_callback, 0);
	createTrackbar("h_max", "thresholdbar", &h_max, 255, H_threshold_callback, 0);
	createTrackbar("s_min", "thresholdbar", &s_min, 255, s_threshold_callback, 0);
	createTrackbar("s_max", "thresholdbar", &s_max, 255, S_threshold_callback, 0);
	createTrackbar("i_min", "thresholdbar", &i_min, 255, i_threshold_callback, 0);
	createTrackbar("i_max", "thresholdbar", &i_max, 255, I_threshold_callback, 0);

	VideoCapture capture;
	capture.open(0);
	while (1)
	{
		Mat frame;
		capture.read(frame);
		Mat pro_img = Mat::zeros(frame.rows, frame.cols, CV_8UC3);
		guass(frame, &pro_img, 0.5);
		Mat pro_img1 = Mat::zeros(frame.rows, frame.cols, CV_8UC3);

		//Mat h = RGB2HSI(pro_img);
		rgb2hsi2(&pro_img, &pro_img1);
		Mat pro_img2 = Mat::zeros(frame.rows, frame.cols, CV_8UC1);
		threshold(h_min, h_max,s_min,s_max,i_min,i_max, &pro_img1, &pro_img2);
		imshow("after",pro_img2);
		

		vector<vector<Point>> contours;
		vector<Vec4i> hierarchy;
		findContours(pro_img2, contours, hierarchy, RETR_LIST, CHAIN_APPROX_NONE, Point());

		Mat imageContours = Mat::zeros(pro_img2.size(), CV_8UC1);

		Mat Contours = Mat::zeros(pro_img2.size(), CV_8UC1);  //绘制  

		for (int i = 0; i < contours.size(); i++)
		{
			//contours[i]代表的是第i个轮廓，contours[i].size()代表的是第i个轮廓上所有的像素点数  
			for (int j = 0; j < contours[i].size(); j++)
			{
				//绘制出contours向量内所有的像素点  
				Point P = Point(contours[i][j].x, contours[i][j].y);

				Contours.at<uchar>(P) = 255;//白色像素点
			}
		}
		//绘制轮廓  
		drawContours(imageContours, contours, -1, Scalar(255));
		imshow("Contours Image", imageContours); //轮廓 

		waitKey(1);
	}
	 
	
	return 0;
}